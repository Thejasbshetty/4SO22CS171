Perfect ðŸ‘
Below is the same Agent 1 code, but structured exactly for a Jupyter Notebook â€” cell by cell.
You can copyâ€“paste each cell and run in order.


---

ðŸ“˜ Jupyter Notebook â€“ Agent 1: Research Coordinator


---

ðŸ§© Cell 1: Imports

from typing import List, Dict, Any
from enum import Enum
import uuid


---

ðŸ§© Cell 2: Task Status Enum

class TaskStatus(Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"


---

ðŸ§© Cell 3: Research Task Model

class ResearchTask:
    def __init__(self, description: str, priority: int):
        self.id = str(uuid.uuid4())
        self.description = description
        self.priority = priority
        self.status = TaskStatus.PENDING
        self.result = None

    def to_dict(self):
        return {
            "id": self.id,
            "description": self.description,
            "priority": self.priority,
            "status": self.status.value,
            "result": self.result,
        }


---

ðŸ§© Cell 4: Agent 1 â€“ Research Coordinator

class ResearchCoordinatorAgent:
    def __init__(self):
        self.tasks: List[ResearchTask] = []

    # 1ï¸âƒ£ Query Decomposition Tool
    def decompose_query(self, query: str) -> List[ResearchTask]:
        print(f"Decomposing query: {query}")
        
        subtasks = [
            ResearchTask("Collect relevant documents from web", priority=1),
            ResearchTask("Analyze trends and patterns", priority=2),
            ResearchTask("Validate facts and sources", priority=3),
            ResearchTask("Format final research output", priority=4),
        ]
        self.tasks.extend(subtasks)
        return subtasks

    # 2ï¸âƒ£ Task Prioritization Tool
    def prioritize_tasks(self):
        self.tasks.sort(key=lambda task: task.priority)

    # 3ï¸âƒ£ Progress Tracking Tool
    def update_task_status(self, task_id: str, status: TaskStatus, result: Any = None):
        for task in self.tasks:
            if task.id == task_id:
                task.status = status
                task.result = result
                return
        raise ValueError("Task not found")

    def get_progress(self) -> Dict[str, int]:
        summary = {
            "pending": 0,
            "in_progress": 0,
            "completed": 0,
        }

        for task in self.tasks:
            summary[task.status.value] += 1

        return summary

    # 4ï¸âƒ£ Result Synthesis Tool
    def synthesize_results(self) -> Dict[str, Any]:
        synthesized_output = {}

        for task in self.tasks:
            if task.status == TaskStatus.COMPLETED:
                synthesized_output[task.description] = task.result

        return {
            "summary": "Final synthesized research output",
            "details": synthesized_output,
        }

    def get_all_tasks(self):
        return [task.to_dict() for task in self.tasks]


---

ðŸ§© Cell 5: Create Agent Instance

agent = ResearchCoordinatorAgent()


---

ðŸ§© Cell 6: Decompose a Research Query

tasks = agent.decompose_query(
    "Analyze recent trends in AI research and validate findings"
)

for task in tasks:
    print(task.to_dict())


---

ðŸ§© Cell 7: Prioritize Tasks

agent.prioritize_tasks()

for task in agent.get_all_tasks():
    print(task)


---

ðŸ§© Cell 8: Simulate Task Execution

for task in agent.tasks:
    agent.update_task_status(
        task.id,
        TaskStatus.COMPLETED,
        result=f"Completed result for: {task.description}"
    )


---

ðŸ§© Cell 9: Check Progress

agent.get_progress()

Expected Output

{'pending': 0, 'in_progress': 0, 'completed': 4}


---

ðŸ§© Cell 10: Final Result Synthesis

final_output = agent.synthesize_results()
final_output


---

âœ… What youâ€™ve achieved

âœ” Built Agent 1 (Orchestrator)
âœ” Query â†’ Tasks â†’ Execution â†’ Synthesis
âœ” Fully Jupyter-compatible
âœ” Ready to plug Agent 2â€“5 later


---

ðŸ”œ Next?

I can:

Build Agent 2 (Web Scraper + RAG) in notebook

Convert this into FastAPI

Add async + multi-agent execution

Integrate MCP tools


Just tell me whatâ€™s next ðŸš€