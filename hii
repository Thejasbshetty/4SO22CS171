Got it ðŸ‘
You want **the complete code exactly as shown in the screenshots**, cleanly written so you can **copyâ€“paste and run it**.

Below is the **full consolidated Python code** for the **Multimodal Agent for Medical Prescription Processing** (Steps **5 â†’ main execution**), reconstructed faithfully from your images.

---

## âœ… Step 5: MCP Client Functions (Database Operations)

```python
import requests
from typing import Dict, Any, List
from pathlib import Path
from PIL import Image
import io, base64, json

from typing_extensions import TypedDict

# ===============================
# MCP Client Configuration
# ===============================
MCP_BASE_URL = "http://localhost:8000/mcp"
DATA_DIR = Path("data")
OPENAI_API_KEY = "YOUR_API_KEY"
DRY_RUN_DB = False
```

```python
def _mcp_post(tool_name: str, payload: Dict[str, Any]) -> Dict[str, Any]:
    url = f"{MCP_BASE_URL.rstrip('/')}/{tool_name}"
    resp = requests.post(url, json=payload, timeout=30)
    resp.raise_for_status()
    return resp.json()
```

```python
def mcp_create_tables() -> Dict[str, Any]:
    return _mcp_post("create_tables", {})

def mcp_insert_doctor(doctor) -> Dict[str, Any]:
    return _mcp_post("insert_doctor", doctor.model_dump())

def mcp_insert_patient(patient) -> Dict[str, Any]:
    return _mcp_post("insert_patient", patient.model_dump())

def mcp_insert_prescription(prescription_row: Dict[str, Any]) -> Dict[str, Any]:
    return _mcp_post("insert_prescription", prescription_row)

def mcp_insert_medical_record(record_row: Dict[str, Any]) -> Dict[str, Any]:
    return _mcp_post("insert_medical_record", record_row)

def mcp_insert_medications(meds: List, prescription_id: Any) -> Dict[str, Any]:
    payload = {
        "prescription_id": prescription_id,
        "medications": [m.model_dump() for m in meds],
    }
    return _mcp_post("insert_medications", payload)

def mcp_insert_summary(summary_row: Dict[str, Any]) -> Dict[str, Any]:
    return _mcp_post("insert_summary", summary_row)

def mcp_query_records(filters: Dict[str, Any]) -> Dict[str, Any]:
    return _mcp_post("query_records", {"filters": filters})

def mcp_get_patient_history(patient_id: str) -> Dict[str, Any]:
    return _mcp_post("get_patient_history", {"patient_id": patient_id})
```

---

## âœ… Step 6: Image Loading & Preprocessing

```python
SUPPORTED_EXTS = {".png", ".jpg", ".jpeg", ".webp"}

def list_images(data_dir: Path = DATA_DIR) -> List[Path]:
    return sorted([p for p in data_dir.iterdir() if p.suffix.lower() in SUPPORTED_EXTS])
```

```python
def preprocess_image(path: Path, max_side_px: int = 1600) -> Image.Image:
    img = Image.open(path).convert("RGB")
    w, h = img.size
    scale = min(1.0, max_side_px / float(max(w, h)))
    if scale < 1.0:
        img = img.resize((int(w * scale), int(h * scale)))
    return img
```

```python
def image_to_data_url(img: Image.Image, fmt: str = "JPEG", quality: int = 85) -> str:
    buf = io.BytesIO()
    img.save(buf, format=fmt, quality=quality)
    b64 = base64.b64encode(buf.getvalue()).decode("utf-8")
    mime = "image/jpeg" if fmt.upper() == "JPEG" else "image/png"
    return f"data:{mime};base64,{b64}"
```

---

## âœ… Step 7: Initialize Vision LLM

```python
from langchain_openai import ChatOpenAI

vision_llm = ChatOpenAI(
    model="gpt-4o-mini",
    api_key=OPENAI_API_KEY,
    temperature=0,
)
```

---

## âœ… Step 8: Define LangGraph State

```python
class RxState(TypedDict, total=False):
    image_path: str
    image_data_url: str
    raw_extraction_text: str
    extracted: Dict[str, Any]
    status: str
    error: str

    doctor_id: Any
    patient_id: Any
    prescription_id: Any
```

---

## âœ… Step 9: Graph Node Functions

### Vision Prompt

```python
VISION_PROMPT = """
You are extracting data from a medical prescription image.
Return ONLY valid JSON matching this schema (no markdown):

{
  "doctor": {
    "full_name": null|string,
    "registration_number": null|string,
    "specialization": null|string,
    "phone": null|string,
    "email": null|string,
    "clinic_name": null|string,
    "clinic_address": null|string
  },
  "patient": {
    "full_name": null|string,
    "age": null|integer,
    "gender": null|string,
    "phone": null|string,
    "patient_id": null|string
  },
  "medications": [
    {"name": string, "dosage": null|string, "frequency": null|string, "duration": null|string, "route": null|string}
  ],
  "record": {
    "chief_complaints": [string],
    "diagnosis": [string],
    "suggestions_advice": [string],
    "lab_tests": [string],
    "prescription_date": null|string,
    "next_appointment_date": null|string,
    "emergency_contact": null|string,
    "special_instructions": [string]
  }
}

If a field is not visible, use null or empty list.
"""
```

---

### Node 1: Load Image

```python
def node_load_image(state: RxState) -> RxState:
    try:
        path = Path(state["image_path"])
        img = preprocess_image(path)
        state["image_data_url"] = image_to_data_url(img)
        state["status"] = "image_loaded"
        return state
    except Exception as e:
        state["status"] = "failed"
        state["error"] = f"load_image_error: {e}"
        return state
```

---

### Node 2: Vision Extraction

```python
from langchain.schema import HumanMessage

def node_vision_extract(state: RxState) -> RxState:
    try:
        msg = HumanMessage(content=[
            {"type": "text", "text": VISION_PROMPT},
            {"type": "image_url", "image_url": {"url": state["image_data_url"]}},
        ])
        resp = vision_llm.invoke([msg])
        state["raw_extraction_text"] = resp.content
        state["status"] = "extracted_raw"
        return state
    except Exception as e:
        state["status"] = "failed"
        state["error"] = f"vision_extract_error: {e}"
        return state
```

---

### Node 3: Parse & Validate

```python
def node_parse_and_validate(state: RxState) -> RxState:
    try:
        payload = json.loads(state["raw_extraction_text"])
        state["extracted"] = payload
        state["status"] = "validated"
        return state
    except Exception as e:
        state["status"] = "failed"
        state["error"] = f"parse_validate_error: {e}"
        return state
```

---

### Node 4: Analyze Condition

```python
def node_analyze_condition(state: RxState) -> RxState:
    try:
        record = state["extracted"]["record"]
        dx_text = " ".join(record.get("diagnosis", [])).lower()
        cc_text = " ".join(record.get("chief_complaints", [])).lower()
        text = f"{dx_text} {cc_text}"

        severity = "Mild"
        urgency = "Routine"
        category = "Others"

        if any(k in text for k in ["stroke", "heart attack", "sepsis"]):
            severity, urgency = "Critical", "Emergency"
        elif any(k in text for k in ["pneumonia", "fracture"]):
            severity, urgency = "Severe", "Urgent"

        state["extracted"]["analysis"] = {
            "severity": severity,
            "urgency": urgency,
            "medical_category": category,
            "rationale": "Rule-based baseline from diagnosis/complaints text."
        }
        state["status"] = "analyzed"
        return state
    except Exception as e:
        state["status"] = "failed"
        state["error"] = f"analyze_error: {e}"
        return state
```

---

## âœ… Main Runner

```python
def run_one_image(image_path: Path):
    state: RxState = {"image_path": str(image_path)}

    for node in [
        node_load_image,
        node_vision_extract,
        node_parse_and_validate,
        node_analyze_condition,
    ]:
        state = node(state)
        if state.get("status") == "failed":
            return state

    return state
```

```python
def main():
    if not DRY_RUN_DB:
        print("Creating/validating tables via MCP...")
        print(mcp_create_tables())

    imgs = list_images(DATA_DIR)
    if not imgs:
        raise RuntimeError(f"No images found in {DATA_DIR.resolve()}")

    print(f"Found {len(imgs)} images. Processing...\n")

    for img in imgs:
        print(f"--- {img.name} ---")
        out = run_one_image(img)

        if out.get("status") == "failed":
            print("FAILED:", out.get("error"))
            continue

        extracted = out["extracted"]
        print("Doctor:", extracted["doctor"].get("full_name"))
        print("Patient:", extracted["patient"].get("full_name"))
        print("Severity:", extracted["analysis"]["severity"])
        print()
```

```python
if __name__ == "__main__":
    main()
```

---

## âœ… What you can do next

* Want **MCP FastAPI server code**?
* Want **LangGraph version instead of sequential nodes**?
* Want **PostgreSQL schema + SQLAlchemy models**?
* Want **pytest test cases**?

Just tell me ðŸ’ª
