Got it ðŸ‘
You want Agent 1: Research Coordinator Agent â€” the master orchestrator that decomposes queries, prioritizes tasks, tracks progress, and synthesizes results.

Below is a clean, minimal, working Python implementation that you can directly use or extend.
This is framework-agnostic (no LangChain/Autogen yet), so itâ€™s easy to understand and later plug into MCP tools.


---

ðŸ§  Agent 1 â€“ Research Coordinator Agent (Core Logic)

ðŸ”¹ Responsibilities covered

âœ… Query decomposition
âœ… Task prioritization
âœ… Agent execution tracking
âœ… Result synthesis


---

ðŸ“ agent_1_research_coordinator.py

from typing import List, Dict, Any
from enum import Enum
import uuid


# -------------------------------
# Task Status Enum
# -------------------------------
class TaskStatus(Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"


# -------------------------------
# Task Model
# -------------------------------
class ResearchTask:
    def __init__(self, description: str, priority: int):
        self.id = str(uuid.uuid4())
        self.description = description
        self.priority = priority
        self.status = TaskStatus.PENDING
        self.result = None

    def to_dict(self):
        return {
            "id": self.id,
            "description": self.description,
            "priority": self.priority,
            "status": self.status.value,
            "result": self.result,
        }


# -------------------------------
# Agent 1: Research Coordinator
# -------------------------------
class ResearchCoordinatorAgent:
    def __init__(self):
        self.tasks: List[ResearchTask] = []

    # 1ï¸âƒ£ Query Decomposition Tool
    def decompose_query(self, query: str) -> List[ResearchTask]:
        """
        Breaks a complex research query into smaller tasks
        """
        subtasks = [
            ResearchTask("Collect relevant documents from web", priority=1),
            ResearchTask("Analyze trends and patterns", priority=2),
            ResearchTask("Validate facts and sources", priority=3),
            ResearchTask("Format final research output", priority=4),
        ]
        self.tasks.extend(subtasks)
        return subtasks

    # 2ï¸âƒ£ Task Prioritization Tool
    def prioritize_tasks(self):
        """
        Sort tasks based on priority (lower number = higher priority)
        """
        self.tasks.sort(key=lambda task: task.priority)

    # 3ï¸âƒ£ Progress Tracking Tool
    def update_task_status(self, task_id: str, status: TaskStatus, result: Any = None):
        for task in self.tasks:
            if task.id == task_id:
                task.status = status
                task.result = result
                return
        raise ValueError("Task not found")

    def get_progress(self) -> Dict[str, int]:
        """
        Returns progress summary
        """
        summary = {
            "pending": 0,
            "in_progress": 0,
            "completed": 0,
        }

        for task in self.tasks:
            summary[task.status.value] += 1

        return summary

    # 4ï¸âƒ£ Result Synthesis Tool
    def synthesize_results(self) -> Dict[str, Any]:
        """
        Combines outputs from all completed tasks
        """
        synthesized_output = {}

        for task in self.tasks:
            if task.status == TaskStatus.COMPLETED:
                synthesized_output[task.description] = task.result

        return {
            "summary": "Final synthesized research output",
            "details": synthesized_output,
        }

    # Utility
    def get_all_tasks(self) -> List[Dict]:
        return [task.to_dict() for task in self.tasks]


---

ðŸ§ª Example Usage (Quick Test)

agent = ResearchCoordinatorAgent()

# Step 1: Decompose query
tasks = agent.decompose_query(
    "Analyze recent trends in AI research and validate findings"
)

# Step 2: Prioritize
agent.prioritize_tasks()

# Step 3: Simulate task completion
for task in agent.tasks:
    agent.update_task_status(
        task.id,
        TaskStatus.COMPLETED,
        result=f"Result for: {task.description}"
    )

# Step 4: Get final output
final_result = agent.synthesize_results()
print(final_result)


---

ðŸ”Œ How this maps to your architecture

Requirement	Implemented

Master Orchestrator	âœ…
Query Decomposition	âœ…
Task Priority	âœ…
Progress Tracking	âœ…
Result Synthesis	âœ…
MCP-ready	âœ… (can wrap tools later)



---

ðŸ”œ Next steps (recommended)

Connect Agent 2 (Web Scraper/RAG) as task executors

Add async execution (asyncio)

Convert this into FastAPI service

Integrate MCP tools per task


If you want, next I can: ðŸ‘‰ write Agent 2 code
ðŸ‘‰ convert this to FastAPI + MCP
ðŸ‘‰ show how agents talk to each other

Just tell me ðŸ’¡