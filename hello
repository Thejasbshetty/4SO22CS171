Perfect üëç
We‚Äôll do option 2: step-by-step, and every step will be a separate Jupyter-executable code block so you can run cell by cell.

> ‚ö†Ô∏è Important Jupyter note (please read once):
FastAPI apps don‚Äôt run like normal scripts inside Jupyter.
So:



We‚Äôll define everything in notebook cells

The server will be started in the LAST step using uvicorn via ! command

WebSocket & SSE will still work when you open http://127.0.0.1:8000/docs in browser



---

‚úÖ STEP 1: Install Required Dependencies

üìå Run this once

!pip install fastapi uvicorn python-multipart sse-starlette python-jose passlib[bcrypt]


---

‚úÖ STEP 2: Import Libraries & Initialize FastAPI

from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Depends, HTTPException, BackgroundTasks, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, StreamingResponse
from fastapi.security import OAuth2PasswordBearer
from pydantic import BaseModel, Field
from typing import List, Optional
import time
import asyncio

app = FastAPI(title="Take Away Assignment API")


---

‚úÖ STEP 3: Create Basic REST API Endpoints (CRUD)

Pydantic Model

class Item(BaseModel):
    id: int
    name: str
    price: float

items_db = []

Endpoints

@app.get("/items")
def get_items():
    return items_db


@app.post("/items")
def create_item(item: Item):
    items_db.append(item)
    return item


@app.put("/items/{item_id}")
def update_item(item_id: int, item: Item):
    for i, existing in enumerate(items_db):
        if existing.id == item_id:
            items_db[i] = item
            return item
    raise HTTPException(status_code=404, detail="Item not found")


@app.delete("/items/{item_id}")
def delete_item(item_id: int):
    for item in items_db:
        if item.id == item_id:
            items_db.remove(item)
            return {"message": "Item deleted"}
    raise HTTPException(status_code=404, detail="Item not found")


---

‚úÖ STEP 4: Path & Query Parameters

@app.get("/users/{user_id}")
def get_user(
    user_id: int,
    search: Optional[str] = None,
    limit: int = 10
):
    return {
        "user_id": user_id,
        "search": search,
        "limit": limit
    }


---

‚úÖ STEP 5: Request Body Validation (Advanced Pydantic)

class User(BaseModel):
    username: str = Field(..., min_length=3)
    email: str
    age: Optional[int] = Field(None, gt=0)

@app.post("/users")
def create_user(user: User):
    return user


---

‚úÖ STEP 6: WebSocket Endpoint

@app.websocket("/ws")
async def websocket_endpoint(ws: WebSocket):
    await ws.accept()
    try:
        while True:
            data = await ws.receive_text()
            await ws.send_text(f"Echo: {data}")
    except WebSocketDisconnect:
        print("Client disconnected")


---

‚úÖ STEP 7: WebSocket Connection Manager

class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []

    async def connect(self, ws: WebSocket):
        await ws.accept()
        self.active_connections.append(ws)

    def disconnect(self, ws: WebSocket):
        self.active_connections.remove(ws)

    async def broadcast(self, message: str):
        for conn in self.active_connections:
            await conn.send_text(message)

manager = ConnectionManager()

@app.websocket("/ws/broadcast")
async def broadcast_ws(ws: WebSocket):
    await manager.connect(ws)
    try:
        while True:
            msg = await ws.receive_text()
            await manager.broadcast(msg)
    except WebSocketDisconnect:
        manager.disconnect(ws)


---

‚úÖ STEP 8: Server-Sent Events (SSE)

async def event_generator():
    for i in range(5):
        yield f"data: Event {i}\n\n"
        await asyncio.sleep(1)

@app.get("/sse")
def sse():
    return StreamingResponse(event_generator(), media_type="text/event-stream")


---

‚úÖ STEP 9: SSE with LLM-Style Streaming (Mocked)

async def llm_stream():
    words = ["Hello", "this", "is", "LLM", "streaming"]
    for word in words:
        yield f"data: {word}\n\n"
        await asyncio.sleep(0.8)

@app.get("/llm-stream")
def llm_sse():
    return StreamingResponse(llm_stream(), media_type="text/event-stream")


---

‚úÖ STEP 10: Middleware (CORS + Logging)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.middleware("http")
async def log_requests(request, call_next):
    start = time.time()
    response = await call_next(request)
    duration = time.time() - start
    response.headers["X-Process-Time"] = str(duration)
    return response


---

‚úÖ STEP 11: Authentication & Security (JWT-style)

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

def fake_verify_token(token: str = Depends(oauth2_scheme)):
    if token != "secret":
        raise HTTPException(status_code=401, detail="Invalid token")
    return token

@app.get("/secure")
def secure_route(token: str = Depends(fake_verify_token)):
    return {"message": "Authenticated"}


---

‚úÖ STEP 12: Error Handling & Custom Exceptions

@app.exception_handler(ValueError)
async def value_error_handler(request, exc):
    return JSONResponse(
        status_code=400,
        content={"error": str(exc)}
    )


---

‚úÖ STEP 13: Background Tasks

def write_log(message: str):
    with open("log.txt", "a") as f:
        f.write(message + "\n")

@app.post("/notify")
def notify(bg: BackgroundTasks):
    bg.add_task(write_log, "Notification sent")
    return {"status": "Task started"}


---

‚úÖ STEP 14: File Upload & Download

@app.post("/upload")
def upload(file: UploadFile = File(...)):
    return {
        "filename": file.filename,
        "content_type": file.content_type
    }

@app.get("/download")
def download():
    return {"message": "Pretend this is a file download"}


---

‚úÖ STEP 15: API Documentation

Already done automatically üéâ
Visit:

http://127.0.0.1:8000/docs


---

‚úÖ STEP 16: Run the Server (LAST CELL)

üìå Run this in the final cell only

!uvicorn __main__:app --reload

If that fails in your environment, use:

!uvicorn notebook:app --reload


---

‚úÖ What you now have

‚úî Fully working FastAPI assignment
‚úî Interview-ready features
‚úî Notebook-friendly execution
‚úî Easy to explain each step

If you want next:

üß™ How to test each endpoint

üì¶ Convert this into a proper project structure

üìù One-page explanation for submission


Just say the word üí™